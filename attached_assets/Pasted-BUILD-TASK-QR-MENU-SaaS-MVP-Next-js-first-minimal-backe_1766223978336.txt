BUILD TASK — QR-MENU SaaS MVP (Next.js-first, minimal backend, cost-efficient)

Goal:
Create a production-ready MVP for a QR-Menu SaaS for cafés. Prioritize low hosting cost and fast launch. Use Next.js (serverless/API routes) for frontend + light backend logic. Use MongoDB Atlas (free tier) as DB and Cloudinary (or similar) for image hosting. Deploy frontend on Vercel. Keep server usage minimal using SSG/ISR + on-demand revalidation for public menu pages.

Important notes:

Single QR per café (or optional per-table param); QR URL must never change. QR should be downloadable as PNG with a nice designed background.
No customer auth. Only Café Owner (Admin) authenticates.
Admin can choose between Digital Menu (structured items + categories + offers) OR Image Menu (upload scanned/printed menu image). If Image Menu is chosen, that image is shown to customers after scanning QR.
If no menu set, show a “Menu coming soon” placeholder.
Provide a 7–14 day free trial and subscription via Razorpay (basic subscription flow is fine for v0).
Performance: public menu pages should be SSG/ISR on Vercel; when admin updates menu, call on-demand revalidation to update the static page instantly.
Keep backend minimal and serverless-friendly (use Next.js API routes / serverless functions). If heavier backend needed later, Render/AWS can be used.
Image example to consider for "printed menu image" look/format:
https://5.imimg.com/data5/SELLER/Default/2024/6/430893742/TA/HU/QO/117120085/punch-tape-paper-1000x1000.jpg

Tech stack (required):

Frontend & minimal backend: Next.js (App or Pages router, but prefer Pages for simple SSG/ISR + API routes)
Database: MongoDB Atlas (free tier)
Images: Cloudinary (free tier) or store on S3 if preferred
QR generation: qrcode npm library (serverless generates PNG/dataURL)
Payments: Razorpay checkout + webhook for subscription confirmation
Auth (admin): JWT-based minimal auth (bcrypt for passwords) or NextAuth credentials if easier
Hosting: Vercel for frontend + API routes (primary); optional Render/Railway for any persistent backend
Deliverables (exact):

Full repo scaffold (single repo) with clear folders (see structure below).
Implemented features (Phase 1 complete):
Admin Signup / Login (email/password) + basic profile
Create Café profile (name, logo, contact, address)
On profile creation: generate and store a permanent QR URL for that café — provide a “Download QR PNG” button (background design applied)
Admin dashboard: toggle menu type (digital vs image)
Digital menu CRUD: categories, items (name, description, price, optional image), offers/specials
Image menu upload: admin can upload scanned printed menu image (single file) and set as active menu
Public menu page: mobile-first page accessible by QR URL showing digital menu OR image menu OR placeholder
Razorpay subscription integration + 7–14 day free trial (webhook to mark subscription active and set expiresAt)
Minimal admin subscription UI showing trial days left or subscription status
API spec and sample routes (see below)
MongoDB schema definitions
Instructions to run locally and deploy to Vercel + set required env vars
Minimal tests or test instructions to verify critical flows (QR generation, menu update + revalidate, Razorpay webhook)
Comments in code explaining major parts and a README with setup & deployment steps
Folder structure (suggested):
/
├─ README.md
├─ package.json
├─ next.config.js
├─ /pages
│  ├─ /api
│  │  ├─ auth/login.js
│  │  ├─ auth/register.js
│  │  ├─ cafe/create.js
│  │  ├─ cafe/[cafeId]/menu.js       // public menu API (if needed)
│  │  ├─ cafe/[cafeId]/qr.js         // generate/download QR (serverless)
│  │  ├─ subscription/razorpay-webhook.js
│  ├─ /dashboard
│  │  ├─ index.js                    // admin dashboard home
│  │  ├─ menu.js                     // admin menu management UI
│  │  ├─ upload-image.js
│  ├─ /menu/[cafeSlug].js            // public SSG/ISR page for menu (customer)
├─ /lib
│  ├─ db.js
│  ├─ auth.js
│  ├─ qrcode.js
│  ├─ revalidate.js
├─ /models
│  ├─ Cafe.js
│  ├─ MenuItem.js
│  ├─ Offer.js
│  ├─ Subscription.js
├─ /components
│  ├─ AdminNav.jsx
│  ├─ MenuItemCard.jsx
│  ├─ OfferBanner.jsx
│  ├─ QRDownload.jsx
└─ /styles

MongoDB Schemas (concise)

Cafe

Recommended API routes (minimal)

POST /api/auth/register → register owner (returns JWT)
POST /api/auth/login → login (returns JWT)
POST /api/cafe/create → create cafe profile; generate slug + qrUrl; return qr data URL for download
GET /api/cafe/:slug/menu → public menu data (used by SSG/ISR fetch or client fetch)
POST /api/cafe/:id/menu-item → add item (auth)
PUT /api/cafe/:id/menu-item/:itemId → edit item (auth)
POST /api/cafe/:id/upload-image → upload printed menu (use Cloudinary) (auth)
POST /api/cafe/:id/toggle-menu-type → switch between digital/image (auth) -> triggers revalidation
POST /api/subscription/create → create Razorpay checkout session (auth)
POST /api/subscription/webhook → Razorpay webhook to confirm payment/subscription
Performance + cost-reduction strategy (explicit)

SSG/ISR for public menu pages:
Build /menu/[slug] as SSG with getStaticProps + revalidate: false (or long TTL) and use on-demand revalidation when admin updates menu. This means most customer requests are served from Vercel CDN (very cheap/no server cost).
When admin changes menu or uploads image, call Next.js revalidate API (res.revalidate('/menu/<slug>')) or use Vercel On-Demand ISR.
Use Cloudinary (or similar) to host images so images served from CDN, not your server.
Minimal serverless functions for admin actions (create menu items, upload webhook). Avoid long-running servers.
Cache menu JSON at CDN edge; only revalidate on admin edit.
Use serverless QR generation that returns a data URL or a downloadable PNG; store only the qrUrl string in DB (no heavy storage).
UI / Pages & components plan (how many pages & components — minimal)
Admin / Dashboard (Next.js, protected)

/dashboard — home: QR, subscription status, quick links
/dashboard/menu — list categories & items, button to open modal to add/edit item
/dashboard/offers — add/edit offers
/dashboard/upload — upload printed menu image + toggle menu type
/dashboard/subscription — Razorpay payment button + trial info Customer side (public)
/menu/[slug] — mobile-first menu page:
If menuType === 'image' -> show full-screen image with pinch/zoom
If menuType === 'digital' -> show offers banner, categories, item cards with image, price, add-to-cart (optional later)
Placeholder state if no menu Components:
Header (cafe name/logo), OfferBanner, CategoryList, ItemCard, QRDownload (in Admin dashboard)
UX rules & constraints:

Menu page must load under 2s on mobile (use SSG + Cloudinary).
No customer auth or pop-ups on initial release.
Admin flows must be extremely simple: create cafe → QR generated → add items/menu image.
Deployment & env vars (instructions)

ENV: MONGODB_URI, CLOUDINARY_CLOUD_NAME, CLOUDINARY_API_KEY, CLOUDINARY_API_SECRET, RAZORPAY_KEY_ID, RAZORPAY_KEY_SECRET, JWT_SECRET
Deploy frontend (Next.js) to Vercel. Configure environment variables on Vercel.
Connect to MongoDB Atlas (allow Vercel IPs or use standard connection string).
Set up Razorpay webhook endpoint URL in Razorpay dashboard (point to /api/subscription/webhook on Vercel).
Testing checklist for v0:

Create owner account → create cafe → QR generated and downloadable
Scan QR URL → placeholder shown if no menu
Add digital items → menu page updates (trigger revalidate) and public page shows items
Upload image menu → public page shows image
Toggle between digital & image menu
Razorpay checkout test + webhook marks subscription active
Extra deliverable: small README marketing pitch (one paragraph) the admin can read to café owner: “Why pay ₹199/month” with the quick ROI calculation (5% average bill uplift example).

Priority for v0:

Sign-up/login, create cafe + QR generation, public menu page (SSG/ISR), digital menu CRUD OR image upload toggle, revalidation on update.
Razorpay subscription (basic) + trial.
Polish UI, mobile design, QR download PNG with background.
Quality expectations:

Clean, commented code
Clear README with run & deploy steps
Use environment variables (no hard-coded secrets)
Keep serverless cold-starts minimized by using SSG for public pages
END OF PROMPT — please produce:

Folder scaffold and starter files
Sample implementation for the main flows described
README with local run & Vercel deploy instructions
Notes on where to change settings for production (Razorpay keys, DB URL, Cloudinary)